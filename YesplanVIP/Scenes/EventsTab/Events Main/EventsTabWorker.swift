//
//  EventsTabWorker.swift
//  YesplanVIP
//
//  Created by Techcc - FOH - Video on 22/08/18.
//  Copyright (c) 2018 Yesplan. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import PromiseKit

class EventsTabWorker {
    
    func getEvents(_ path: String) -> Promise<Events> {
        return firstly {
            APIClient.events("\(path)")
        }
            .map({$0})
    }
    
    func groupEventsByStartdate(events: Events) -> Promise<[String:[Event]]> {
        let dictEvents = Dictionary(grouping: events.data, by: { $0.startdate! })
        return Promise { seal in
            seal.resolve(.fulfilled(dictEvents))
        }
    }
    
    func sortEventsInEachGroupByTime(dictEvents: [String:[Event]]) -> Promise<[String:[Event]]> {
        
        var events: [String:[Event]] = [String:[Event]]()
        for (key, value) in dictEvents {
            let valueSorted = value.sorted{ $0.defaultschedulestarttime ?? "no starttime" <  $1.defaultschedulestarttime ?? "no endtime" }
            events[key] = valueSorted
        }
        return Promise { seal in
            seal.resolve(.fulfilled(events))
        }
    }

    func sortDictByDate(dictEvents: [String:[Event]]) -> Promise<[(key: String, value: [Event])]> {

        let sortedDictByDate = dictEvents.sorted(by:  { $0.0 < $1.0 })
        return Promise { seal in
            seal.resolve(.fulfilled(sortedDictByDate))
        }
    }
    
    func getProfiles() -> Promise<Profiles> {
        return firstly {
        APIClient.profiles("")
            .map({$0})
        }
    }

//    func getProfiles() -> Future<Profiles> {
//        return Future(operation: { completion in
//        APIClient.profiles("")
//            .map({$0})
//            .execute(onSuccess: { items in
//                completion(.success(items))
//            }, onFailure: { error in
//                 completion(.failure(error))
//            })
//        })
//    }
    
    func getStatuses() -> Promise<Statuses> {
        return firstly {
              APIClient.statuses("")
                  .map({$0})
        }
      }
    
//    func getStatuses() -> Future<Statuses> {
//        return Future(operation: { completion in
//            APIClient.statuses("")
//                .map({$0})
//                .execute(onSuccess: { items in
//                    completion(.success(items))
//                }, onFailure: { error in
//                    completion(.failure(error))
//                })
//        })
//    }
    
    func showErrorPopup(e:Error) {
        print("An error occured \(e)")
    }
}

// ******************************************

// not used, but keep for future uses:

//    func getProfileDict(profiles: Profiles) -> Future<[String:String]> {
//
//        var profileDict: [String:String] = [:]
//        for i in 0 ..< profiles.data.count {
//            profileDict[profiles.data[i].id] = profiles.data[i].color
//        }
//
//        return Future(value: profileDict)
//    }

//    func getStatuses() -> Promise<[String:String]> {
//
//        var statusDict: [String:String] = [:]
//        let statuses: Statuses = Statuses()
//        yesplan.getAll(statuses).then { statuses in
//            for i in 0 ..< statuses.data.count {
//                if let statusName = statuses.data[i].name,
//                    let statusBackgroundcolor = statuses.data[i].backgroundcolor {
//                    statusDict[statusName] = statusBackgroundcolor
//                    }
//                }
//            }
//        return Promise(statusDict)
//    }

//    func getDates() -> Promise<String> {
//
//        let now = Date()
//        let formatter = DateFormatter()
//        formatter.timeZone = TimeZone.current
//        formatter.dateFormat = "weekday, dd-MM-yyyy"
//        let selectedDateString = formatter.string(from: now)
//        let selectedEndDate = Calendar.current.date(byAdding: Calendar.Component.day, value: 10, to: now)
//        let selectedEndDateString = formatter.string(from:selectedEndDate!)
//        let dates: String = "\(selectedDateString) TO \(selectedEndDateString)"
//
//        return Promise(dates)
//    }

