//
//  EventsTabWorker.swift
//  YesplanVIP
//
//  Created by Techcc - FOH - Video on 22/08/18.
//  Copyright (c) 2018 Yesplan. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import PromisedFuture

class EventsTabWorker {
    
    func getEvents(_ path: String) -> Future<Events> {
        return Future(operation: { completion in
            APIClient.events("\(path)")
                .map({$0})
                .execute(onSuccess: { items in
                    completion(.success(items))
                }, onFailure: { error in
                    completion(.failure(error))
                })
        })
    }
    
    func groupEventsByStartdate(events: Events) -> Future<[String:[Event]]> {
        
        let dictEvents = Dictionary(grouping: events.data, by: { $0.startdate! })
        return Future(value: dictEvents)
    }

    func sortEventsInEachGroupByTime(dictEvents: [String:[Event]]) -> Future<[String:[Event]]> {

        var events: [String:[Event]] = [String:[Event]]()
        for (key, value) in dictEvents {
            let valueSorted = value.sorted{ $0.defaultschedulestarttime ?? "no starttime" <  $1.defaultschedulestarttime ?? "no endtime" }
            events[key] = valueSorted
        }
        return Future(value: events)
    }

    func sortDictByDate(dictEvents: [String:[Event]]) -> Future<[(key: String, value: [Event])]> {

        let sortedDictByDate = dictEvents.sorted(by:  { $0.0 < $1.0 })
        return Future(value: sortedDictByDate)
    }

    func getProfiles() -> Future<Profiles> {
        return Future(operation: { completion in
        APIClient.profiles("")
            .map({$0})
            .execute(onSuccess: { items in
                completion(.success(items))
            }, onFailure: { error in
                 completion(.failure(error))
            })
        })
    }
    
    func getStatuses() -> Future<Statuses> {
        return Future(operation: { completion in
            APIClient.statuses("")
                .map({$0})
                .execute(onSuccess: { items in
                    completion(.success(items))
                }, onFailure: { error in
                    completion(.failure(error))
                })
        })
    }
    
    func showErrorPopup(e:Error) {
        print("An error occured \(e)")
    }
}

// ******************************************

// not used, but keep for future uses:

//    func getProfileDict(profiles: Profiles) -> Future<[String:String]> {
//
//        var profileDict: [String:String] = [:]
//        for i in 0 ..< profiles.data.count {
//            profileDict[profiles.data[i].id] = profiles.data[i].color
//        }
//
//        return Future(value: profileDict)
//    }

//    func getStatuses() -> Promise<[String:String]> {
//
//        var statusDict: [String:String] = [:]
//        let statuses: Statuses = Statuses()
//        yesplan.getAll(statuses).then { statuses in
//            for i in 0 ..< statuses.data.count {
//                if let statusName = statuses.data[i].name,
//                    let statusBackgroundcolor = statuses.data[i].backgroundcolor {
//                    statusDict[statusName] = statusBackgroundcolor
//                    }
//                }
//            }
//        return Promise(statusDict)
//    }

//    func getDates() -> Promise<String> {
//
//        let now = Date()
//        let formatter = DateFormatter()
//        formatter.timeZone = TimeZone.current
//        formatter.dateFormat = "weekday, dd-MM-yyyy"
//        let selectedDateString = formatter.string(from: now)
//        let selectedEndDate = Calendar.current.date(byAdding: Calendar.Component.day, value: 10, to: now)
//        let selectedEndDateString = formatter.string(from:selectedEndDate!)
//        let dates: String = "\(selectedDateString) TO \(selectedEndDateString)"
//
//        return Promise(dates)
//    }

