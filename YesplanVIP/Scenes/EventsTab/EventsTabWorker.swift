//
//  EventsTabWorker.swift
//  YesplanVIP
//
//  Created by Techcc - FOH - Video on 22/08/18.
//  Copyright (c) 2018 Yesplan. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
//import then
import PromiseKit

class EventsTabWorker {
    
    var yesplan: Yesplan = Yesplan()
    var events: Events = Events()
    
     func makePromiseChain() {
        firstly {
            getItems(Resourcebookings())
//            }.then { items in
//                print("items: ", items)
////                URLSession.shared.dataTask(.promise, with: URL(string: avatarStringUrl)!)
////            }.compactMap { data, urlResponse in
//////                UIImage(data: data)
////                print("data: ", data)
//            
            }.done { items in
//                self.imageView.image = image
                print("pagination: ", items.pagination)
                
                for item in items.data {
//                    print("item", item)
                
//                    dump(item.profiles)
                    switch item {
                    case  .instantiableResourceUse(let x):
                        print("type: instantiableResourceUse")
                        print("type: ", x._type)
                        print("url: ", x.url)
                    case  .instantiableResourceUseGroup(let x):
                        print("type: instantiableResourceUseGroup")
                        print("type: ", x._type)
                        print("url: ", x.url)
                    case  .resourceSetUse(let x):
                        print("type: resourceSetUse")
                        print("type: ", x._type)
                        print("url: ", x.url)
                    case  .freeFormResourceUse(let x):
                        print("type: freeFormResourceUse")
                        print("type: ", x._type)
                        print("url: ", x.url)
                    case  .bulkResourceUse(let x):
                        print("type: bulkResourceUse")
                        print("type: ", x._type)
                        print("url: ", x.url)
                    }
                }
            }.catch { error in
                print(error)
        }
    }
    
    func getItems<T:Decodable>(_ t: T) -> Promise<T> {
        return Promise<T> { seal in
            guard let url = URL(string: "https://dewerft.yesplan.be/api/resourcebookings?api_key=C857C01360BB5777DABE5B7EE6594CD1") else { return }
            URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in
                guard let data = data, error == nil else { return }
                do {
                    let decoder = JSONDecoder()
                    let json = try decoder.decode(T.self, from: data)
                    seal.fulfill(json)
                } catch let error {
                    seal.reject(error)
                }
            }).resume()
        }
    }
    
    func printFetchedEvents(events: Events) -> Events {
        
        print("events: \(events)")
        return events
    }
    
    func groupEventsByStartdate(events: Events) -> [String:[Event]] {
        
        let dictEvents = Dictionary(grouping: events.data, by: { $0.startdate! })
        return dictEvents
    }
    
    func printGroupedEventsByStartdate(dictEvents: [String:[Event]])  -> [String:[Event]] {
        
        print("dictEvents: ", dictEvents)
        return dictEvents
    }
    
    func sortEventsInEachGroupByTime(dictEvents: [String:[Event]]) -> [String:[Event]] {
        
        var events: [String:[Event]] = [String:[Event]]()
        for (key, value) in dictEvents {
            let valueSorted = value.sorted{ $0.defaultschedulestarttime ?? "no starttime" <  $1.defaultschedulestarttime ?? "no endtime" }
            events[key] = valueSorted
        }
        return events
    }
    
    func printsortedEventsInEachGroupByTime(dictEvents: [String:[Event]]) {
        
        print("dictEvents: ", dictEvents)
    }
    
    func sortDictByDate(dictEvents: [String:[Event]]) -> [(key: String, value: [Event])] {
        
        let sortedDictByDate = dictEvents.sorted(by:  { $0.0 < $1.0 })
        return sortedDictByDate
    }
    
//    func getDates() -> Promise<String> {
//
//        let now = Date()
//        let formatter = DateFormatter()
//        formatter.timeZone = TimeZone.current
//        formatter.dateFormat = "weekday, dd-MM-yyyy"
//        let selectedDateString = formatter.string(from: now)
//        let selectedEndDate = Calendar.current.date(byAdding: Calendar.Component.day, value: 10, to: now)
//        let selectedEndDateString = formatter.string(from:selectedEndDate!)
//        let dates: String = "\(selectedDateString) TO \(selectedEndDateString)"
//
//        return Promise(dates)
//    }
//
//    func getProfiles() -> Promise<[String:String]> {
//
//        var profileDict: [String:String] = [:]
//        let profiles: Profiles = Profiles()
//        yesplan.getAll(profiles).then { profiles in
//            for i in 0 ..< profiles.data.count {
//                profileDict[profiles.data[i].id] = profiles.data[i].color
//            }
//        }
//        return Promise(profileDict)
//    }
    
    func printProfiles(profiles: Profiles) {
        print("profiles: \(profiles)")
    }

//    func getStatuses() -> Promise<[String:String]> {
//
//        var statusDict: [String:String] = [:]
//        let statuses: Statuses = Statuses()
//        yesplan.getAll(statuses).then { statuses in
//            for i in 0 ..< statuses.data.count {
//                if let statusName = statuses.data[i].name,
//                    let statusBackgroundcolor = statuses.data[i].backgroundcolor {
//                    statusDict[statusName] = statusBackgroundcolor
//                    }
//                }
//            }
//        return Promise(statusDict)
//    }
    
    func printStatuses(statuses: Statuses) {
        print("statuses: \(statuses)") 
    }
    
    func showErrorPopup(e:Error) {
        print("An error occured \(e)")
    }
}
